## 二分图问题-最大匹配问题

最大匹配问题是定义在二分图上的问题，问题的前提是采取了二分图划分。

### 定义

在图中选择**最多的不相交边**，使得每个点最多出现在**一条边中**。

例子：

| 问题 | 表述 | 分类对象1 | 分类对象2 |
|-------|-------|----|-|
| 人和分工 | 将工人分到合适的工作上，达成利用率最高的分工 | 人 | 工作|
| 单身男女配对 | 一个男性搭配一名女性，根据条件达成最多组的配对 | 男 | 女|
| 集合中的质数组合 | 一个整数搭配另一个整数，相加后得到质数，求最多可能的质数组合 | 奇数 | 偶数|

**Tips：除了2以外，质数必然可表示为奇数和偶数的的和**

分类的依据应当从问题的实际情况来出发，从原本的集合当中划出二分图。

---

### 解决方法：匈牙利算法（增广路径）

匈牙利算法是专门用来求解二分图最大匹配的经典算法，基于**增广路径**思想。
他的时间复杂度为O(nm)，n为左侧的节点数，m为边数。

**原理：对每个未匹配的左侧节点 u，从它开始 DFS 找增广路径，成功就扩展匹配。**

### 增广路径

**定义：一条路径，交替地连接“未匹配边”和“已匹配边”，以“未匹配点”开头，“未匹配点”结尾。**

**作用：找到后可以反转路径上边的匹配状态，让匹配边数 +1。**

---

### “小孩抢椅子”模型：

匈牙利算法的步骤可以用小孩抢椅子的方式来进行等效说明，从而有更形象且具体的解释。

**抢椅子的解释**：

有一群 小孩（L） 和一些 椅子（R）。

小孩不能坐任意椅子，只有特定的椅子才会去坐（这个偏好是由“能构成质数对”等具体的规则决定的）。

每把椅子最多只能坐一个小孩。每个小孩最多抢一张椅子。

问题目标是：**安排最多的小孩坐到自己喜欢的椅子上，不能坐则放弃。**

---
## 具体步骤：

#### 1.小孩依次上场抢椅子

按顺序让每个小孩上场抢椅子。一个小孩上场时，就带一张新的尝试记录纸，记录他坐椅子的尝试记录（对应 **visited[]**）。

---

#### 2.小孩试图坐喜欢的椅子（需要用到邻接表graph）

小孩L会根据自己的偏好列表（graph[L]）去试坐每一张椅子R。

每当他尝试椅子R：看下今天有没有尝试抢过某个椅子（visited[R]）——避免重复尝试。

如果没试过，就试试看。

---

#### 3. 椅子无人坐 → 抢座成功
如果椅子R是空的（match_to[R] == -1），L就坐上去。**其中match_to列表表示：第R张椅子上坐的小孩是第L名。**

场务记录：**“椅子R由小孩L占用” → match_to[R] = L**

---

#### 4.椅子已有人 → 请求对方让位
如果椅子R已经有别的小孩L′在坐：

那么，当前小孩L就对L′说：“你能不能去找别的椅子？”

L′则被迫尝试去找其他能坐的椅子（**此步骤相当于递归调用BPM(L′)**，是深度优先搜索DFS）

---
#### 5.如果L′成功换到别的椅子 → L就能坐R
如果 L′ 找到了新椅子坐：那么原来的椅子R就空出来，L 终于坐上去。
然后对场地中的匹配状态更新：match_to[R] = L

---
#### 6.如果L'找不到位置可坐：
本次寻找匹配失败，小孩L不能进行匹配。

---

## 最大匹配的一个代码实现（基于抢椅子的注释）：

```python
# 增广路径算法，匈牙利算法寻找二分图的最大匹配
def bpm(L, visited, match_to, graph):
    # 尝试让小孩L坐上某张椅子R
    for R in graph[L]:  # 遍历小孩L能坐的椅子
        if not visited[R]:  # 如果这把椅子今天还没尝试过
            visited[R] = True  # 标记：尝试过了
            if match_to[R] == -1:
                # 椅子没人坐，直接登记为L坐
                match_to[R] = L
                return True
            else:
                # 椅子有人坐（小孩L'），让L'去找别的椅子
                if bpm(match_to[R], visited, match_to, graph):
                    # 若L'成功换了椅子，那么R空了，L坐上R
                    match_to[R] = L
                    return True
    return False  # 所有椅子都尝试失败

match = [-1]*len(evens)
max_match = 0

# visited[] 每轮都要清空（重置）；孩子抢座位时自己带的尝试表
# match_to[] 却是整个过程都保留（全局匹配状态）；全局记录当前位置被哪个孩子坐
# graph为二分图的两组所构成的邻接表
# 逐个让左侧集合中的元素进行尝试匹配

for i in range(0,len(odds)):
    visited = [False]*len(evens)
    if bpm(odds[i],visited,match,graph):
        max_match += 1
return max_match
```