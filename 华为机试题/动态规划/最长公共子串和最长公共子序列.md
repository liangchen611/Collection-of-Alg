
|特性|子串|子序列
|----|-----|
|是否是连续？|必须连续|不要求连续性
|提取方式|必须是在原字符串|顺序和原来相同，但可不连续|
|实例"abcde"|"bcd"是子串|"ace"为子序列，但不是子串|

---

| 问题类型    | 状态定义                                       | 转移方式                                                   | 特点               |
| ------- | ------------------------------------------ | ------------------------------------------------------ | ---------------- |
| 最长公共子串  | `dp[i][j] = 以 A[i−1], B[j−1] 结尾的公共子串长度`    | `A[i−1]==B[j−1] => dp[i][j]=dp[i−1][j−1]+1`，否则为 0      | 需要连续，相等就 +1，不等就断 |
| 最长公共子序列 | `dp[i][j] = A[0..i−1], B[0..j−1] 的 LCS 长度` | 若相等：`dp[i−1][j−1]+1`；否则取 `max(dp[i−1][j], dp[i][j−1])` | 不要求连续，最长路径型问题    |

---
### 为何最长公共子串在a[i-1]与b[j-1]相等时才在dp[i-1][j-1]上更新?

必须保证串的连续性，某个位置出现了不等，那么就不构成一个公共子串，哪怕前面可以构成也是一样。

在**最长公共子序列(LCS)**中，确实：

A = "a"

B = "aaw"

最长公共子序列是 "a" → 长度 1

但在最长公共子串中，我们要：

1.A 的前缀结尾是某字符

2.B 的前缀结尾是某字符

并且要连续“对上”，从前面一段就要连续对上来,否则直接判为0

