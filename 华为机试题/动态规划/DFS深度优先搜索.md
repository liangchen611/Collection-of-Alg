## 从迷宫问题出发的深度优先搜索问题DFS

给定一个H×W的迷宫网格(0表示路，1表示墙)，问是否能从起点(0, 0)走到终点(H-1, W-1)，并返回一个可达路径，每步只能走上下左右。

---
这个问题的基本思路可以表示为如下的过程：
```python
def dfs(x, y):  #x,y代表横纵坐标
    if 越界 or r[x][y] 是墙:
        return False
    if x, y 是终点:
        return True
    if visited[x][y]:
        return False

    path.append((x,y))

    visited[x][y] = True

    for dx, dy in directions:
        if dfs(x+dx, y+dy):
            return True
    
    path.pop()
    visited[x][y] = False

    return False
```

也可以用另一个基本模板来构建问题模型：

```python
def dfs(state):
    if 不合法(state):
        return

    if 满足目标(state):
        保存结果
        return

    for choice in 可选动作:
        修改状态(state, choice)
        dfs(state)
        恢复状态(state, choice)  # 回溯
```

---
### DFS状态表示

进行搜索前，需要根据问题的情况来合理地表示出状态。以走迷宫问题为例：

**当前搜索位置**：(x, y)

**是否访问过**：visited[x][y]

**可选择的方向**：[(0,1),(1,0),(-1,0),(0,-1)]

---
### DFS的搜索目标

通常为：

- 终点的可达性（返回 True/False）；

- 找到并返回一条路径；

- 找所有路径；

- 找最短路径（一般用 BFS 更好）；

---
### 搜索过程中的剪枝

- 越界；

- 碰到墙；

- 在本次搜索中已经被搜索过（防止重复）；

- 死路；

---
### 搜索过程的递归以及回溯（栈）

- 在进入递归前，需要先在外层进行标记（例如visited[x,y]=True)，防止重复；
- 如果需要搜索并返回一条路径，那么在进入递归前需要先将路径节点入栈；
- 当出现“此路不通”类的回溯时，需要弹出栈元素，例如path.pop()；

---
## DFS中关于栈的应用

### 深度优先搜索的本质就是：每次走到底（优先深入），直到无法继续，再回退一个点，尝试其他方向。

可知这种结构和栈类似。（**先进后出，后进先出**）

### 基本的运用形式：

```python
def dfs_stack(x, y):

    if 越界或无效:
        return

    # 做出当前状态下的选择
    visited[x][y] = True

    for dx, dy in directions:
        dfs(x+dx, y+dy)


    # 选择不成立时，撤销选择（回溯）
    visited[x][y] = False
```

以上的算法构成了如下图一样的基本格式：
```python
dfs(0,0)
  └── dfs(1,0)
        └── dfs(2,0)
              └── dfs(2,1)
                      ...
```

当某一路的递归走不通，被截断时，就回退到上一层的递归状态再继续尝试，这样逐步深入，直到终点后，再逐步退出递归。

---

## DFS与动态规划的区别

|项目|深度优先搜索|动态规划|
||||
|目标|枚举可能的路径，判断可达性|通过递推的方式，得到最优值等
|主要操作|枚举，回溯，通过条件判断来探索分支|“填表”，状态转移
|记忆缓存|用visited来防止死循环|使用dp表来存储状态

**DFS一般不会有状态转移方程dp[i]=f(dp[i-j])，不涉及到状态转换，但因为需要递归与回溯，所以探索条件总是和之前的状态严格相关，这点是和DP的一个区别。**
